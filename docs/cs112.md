<style>.markdown-body {font-family:"Times New Roman", Times, serif;}</style>

CS112 - Data Structures
===

Review of CS111
---

### In the Java Virtual Machine (JVM):

 Stack:
- The stack holds the primitive data type directly in the stack.


	- They are "stacked" in the stack.
	- If they are not a primitive data type, then the stack holds the location of the variable in the "HEAP".
	- The size of items in the stack can  NOT change.


Heap:

- The heap is basically just a jumbo of data with different variables in the stack pointing to the heap.
- The abstract data types are stored in the heap.

Union Find
---

Today, we will see 3 algorithms that have different runtimes.

### Connectivity Problem:
1. m vertices
2. 2 operations:
	- Connect two vertices
	- Is there a path between the two vertices?

#### Algorithm 1 (Union Find):

##### Operation 1: Connections.
- Start off with an array. Each number is a vertice.

| Vertice     | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
|-------------|---|---|---|---|---|---|---|---|---|---|
| Data Stored | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |

1. Connect (3,4), the value under 3 gets replaced by the 4.

| Vertice     | 0 | 1 | 2 | 3       | 4 | 5 | 6 | 7 | 8 | 9 |
|-------------|---|---|---|---------|---|---|---|---|---|---|
| Data Stored | 0 | 1 | 2 | ***4*** | 4 | 5 | 6 | 7 | 8 | 9 |

2. Connect (2,8), the value under 2 gets replaced by the 8.

| Vertice     | 0 | 1 | 2       | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
|-------------|---|---|---------|---|---|---|---|---|---|---|
| Data Stored | 0 | 1 | ***8*** | 4 | 4 | 5 | 6 | 7 | 8 | 9 |


3. Now, if I merge (4, 9), then then **all values** of 4 in the array gets changed.

| Vertice     | 0 | 1 | 2 | 3       | 4       | 5 | 6 | 7 | 8 | 9 |
|-------------|---|---|---|---------|---------|---|---|---|---|---|
| Data Stored | 0 | 1 | 8 | ***9*** | ***9*** | 5 | 6 | 7 | 8 | 9 |

#### Example Union code:


##### Operation 2: Lookups.
- First, you look up the first value. (Ex: Does 4 connect to 9?)
- The value stored at 4 is 9.
- Next, you find the valeu at 9, which is still 9.
- Compare the two, and you will find that they **do** connect.


#### That Up there is TOO SLOW!!! Running in O(n) time.

Instead, we don't store the id of the vertice in the array.

**A parent is the one we designate as the representative of the family.**

##### Example:

| Vertice     | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
|-------------|---|---|---|---|---|---|---|---|---|---|
| Data Stored | 0 | 1 | 9 | 4 | 9 | 6 | 6 | 7 | 8 | 9 |

Parents:

	0 - is 0's parent
	1 - is 1's parent
	3 - is the child of 4
	4 - is the child of 9
	5 - is the child of 6
	6 - the parent of 5
	7 - is 7's parent
	8 - is 8's parent
	9 - is it's own parent

#### This time, (Quick Union - Lazy Approach)
- Lookup occurs by finding the root parent of the number.
- Example: To find whether 2 and 3 are connected, look for the root of 2 first.
	- The root of 2 is 9, 9 is the parent.
  - Look for the root of 3. 3 points to 4, which then points to 9, making the root of 3 be 9.
  - Therefore, 2 is connected to 3.


#### Weighted Quick Union
- Modify quick-union to avoid tall trees.
- Keep track of the size of each tree (number of elements)
- Always link root of smalelr tree to root of larger tree.

##### Analysis:
- Depth of any node (*x*) is *log n*. (log base 2)
	- Everytime you conncet two trees, you will have one tree point to another tree. 

### Cost Model

| algorithm   | initialize | union | find |
|-------------|------------|-------|------|
| quick find  | n          | n     | 1    |
| quick union | n          | n     | n    |

#### If you ALWAYS connect the smaller tree to the bigger tree, you will always have a better running time.





